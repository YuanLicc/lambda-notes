本文总结、摘录自书籍[《Java 8 函数式编程》](https://www.amazon.cn/dp/B00VDSW7AE/ref=sr_1_1?s=books&ie=UTF8&qid=1528162560&sr=1-1&keywords=java+8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)

## Lambda - 并发

#### 阻塞I/O

假设要编写一个支持大量用户的聊天程序。每当用户连接到聊天服务器时，都要和服务器建立一个 TCP 连接。使用传统的线程模型，每次向用户写数据时，都要调用一个方法向用户传输数据，这个方法会阻塞当前线程。 这种 I/O 方式叫阻塞式 I/O，是一种通用且易于理解的方式，因为和程序用户的交互通常符合这样一种顺序执行的方式。缺点是，将系统扩展至支持大量用户时，需要和服务器建 立大量 TCP 连接，因此扩展性不是很好。

#### 非阻塞I/O

非阻塞式 I/O，有时也叫异步 I/O，可以处理大量并发网络连接，而且一个线程可以为多个连接服务。和阻塞式 I/O 不同，对聊天程序客户端的读写调用立即返回，真正的读写操作则在另一个独立的线程执行，这样就可以同时执行其他任务了。如何使用这些省下来的CPU 周期完全取决于程序员，可以选择读入更多数据，也可以玩一局 Minecraft 游戏。Java 标准类库的 NIO 提供了非阻塞式 I/O 的接口，NIO 的最初版本用到了 Selector 的概念，让一个线程管理多个通信管道，比如向客户端写数据的网络套接字。 然而这种方式压根儿就没有在 Java 程序员中流行起来，它编写出来的代码难于理解和调 试。引入 Lambda 表达式后，设计和实现没有这些缺点的 API 就顺手多了。

### 大致介绍

书籍使用了构件[io.vert.x](http://maven.aliyun.com/nexus/#nexus-search;quick~io.vertx) 来实现了一个聊天小程序。我不再做介绍，由于时间问题与我的并发知识并不深，所以暂时不接触这类第三方构件，另外书籍前面章节还使用Lambda表达式对设计模式中的几个模式进行了实现。这些实现都要建立在对设计模式了解的前提下，我也有相应的笔记 [设计模式-笔记](https://github.com/YuanLicc/design-pattern-notes) ，分析其实现而言，与Java 8类库`java.util.stream`类似，其实现主要还是依赖于函数接口，但是其核心还是模式的理解及函数接口的理解，所以学习这类知识不可能看看例子就会了，还需要大量的设计模式实践与理解，因此我并没有摘录此类知识点，需要看的可以在亚马逊购买此书的电子书版本 [《Java 8 函数式编程》](https://www.amazon.cn/dp/B00VDSW7AE/ref=sr_1_1?s=books&ie=UTF8&qid=1528162560&sr=1-1&keywords=java+8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)。

